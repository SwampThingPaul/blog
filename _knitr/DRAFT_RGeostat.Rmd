---
title: "Geospatial data analysis in #rstats"
date: " "
output: 
  prettydoc::html_pretty:
  theme: default
  highlight: github
editor_options: 
  chunk_output_type: console
---

__Keywords:__ kriging, geostatistics, ArcGIS, R

***

Many (many) years ago after graduating from undergrad I was introduced to geographical information systems (GIS) at the time ArcInfo developed by [ESRI](https://www.esri.com/en-us/home) was the leading software to develop, visualise and analyse geospatial data. I quickly took to learning the ins and outs of this software burrowing and begging for licenses to feed my despire to learn GIS. Eventually I moved onto my masters degree where I was able to apply a lot of what I learned. Throughout my career I have had and ESRI icon on my desktop. But it wasn't until I started to learn [R](https://cran.r-project.org/) that I began to see some of the downfalls of the this iconic software. Yes, ArcGIS and its cousins ([GRASS](https://grass.osgeo.org/) and [QGIS](https://qgis.org/en/site/)) are valuable, powerful and irreplaceable analytical tools...no question. Something you learn with R is reproduability and easly tracking what you have done. In spreadsheets (i.e. excel) it tough to find out what cells are calculated and how, in R its all in front of you. In ArcGIS there are countless steps (and clicks) to read in data, project, transform, clip, interpolate, reformat, export, plot, etc.  Unless you are a [python](https://www.python.org/) wizard, most of this is reliant on your ability to remember/document the steps necessary to go from raw data to final product in ArcGIS. Reproducability in data analysis is essental which is why I turned to conducting geospatial analyses in R. Additionally, typing and executing commands in the R console, in many cases is faster and more efficient than pointing-and-clicking around the graphical user interface (GUI) a desktop GIS. 

Thankfully, the R community has contributed trumendously to expand R's ability to conduct spatial analyses by integrating tools from geography, geoinformatics, geocompution and spatial statistics. Râ€™s wide range of spatial capabilities would never have evolved without people willing to share what they were creating or adapting ([Lovelace et al 2019](https://geocompr.robinlovelace.net/){target="_blank"}). The book by Lovelace et al is great start to learning geospatial analysis in R. In addition to this book there are countless other books r-connect pages, blogs, white papers, etc. dedicated to analysing, modeling and visulaizing geospatial data. I emplore you to explore the web for these resources as this blog post is not the one stop shop for info. 

```{r 0, out.width="25%",echo=FALSE,fig.align="center",fig.cap="[Geocomputation with R](https://geocompr.robinlovelace.net/)"}
knitr::include_graphics("https://geocompr.robinlovelace.net/images/cover.png")
```


# [Brass Tacks](https://en.wiktionary.org/wiki/get_down_to_brass_tacks){target="_blank"}

Geospatial analysis may sound daunting. I will walk you through reading, writing, plotting and analyzing geospatial data. In a prior [blog post](https://swampthingpaul.github.io/blog/mapping-in-rstats/){target="_blank"} I outlined some basic mapping in R using the [`tmap`](https://github.com/mtennekes/tmap){target="_blank"} package. 

Let start by loading the necessary (and some unnecessary) R-packages. If you missing ant of the "GIS Libraries" identified below use this [script](https://gist.github.com/SwampThingPaul/d37b222e4fa0f9b72d247c9c79e5b7fd){target="_blank"} to install them, if a package is already installed it will skip and move to next. 

```{r libraries,echo=T,message=F,warning=F}
#Libraries
library(plyr)
library(reshape)
library(openxlsx)
library(vegan)
library(goeveg);
library(MASS)

##GIS Libraries
library(sp)
library(rgdal)
library(gstat)
library(raster)
library(spatstat)
library(maptools)
library(rgeos)
library(spdep)

library(tmap)
library(GISTools)
library(rasterVis)

```

```{r data, include=F}
uf.cols.muted=c(rgb(108/255,154/255,195/255,1,"gator.blue"),rgb(226/255,143/255,65/255,1,"gator.orange"));#office style colors from UF

wd="D:/UF/TaylorSlough/UTS_Soil"

gis.path=paste0(wd,"/GIS_Data")

#data
loc.dat1=readOGR(paste(gis.path,"/Saptial_Trans_2012Sampling",sep=""),"Sample_Sites_fromTZOdata_pro")
attributes(loc.dat1)$proj4string

loc.dat.raw=loc.dat1@data[,c("UTMX","UTMY")]

sp.mod.dat=exp(7.668e-5*loc.dat1@data$UTMY+(-2.099e2))
sp.mod.dat=sp.mod.dat*runif(length(sp.mod.dat),1.2,2.0)
loc.dat1@data$TP_mgkg=sp.mod.dat;#fake data with a spatial gradient

grid=readOGR(paste(gis.path,"/StudyArea_Grid",sep=""),"StudyArea_grid")
attributes(grid)$proj4string
study.area=gUnaryUnion(grid)

fp=readOGR(paste(gis.path,"/StudyArea_Grid",sep=""),"South_DDetention_clip")
ts=readOGR(paste(gis.path,"/StudyArea_Grid",sep=""),"Slough_StudyArea")
road=readOGR(gis.path,"roads_Clipped")
canal=readOGR(gis.path,"sfwmd_canals")

sp.dat=loc.dat1
#plot(TP_mgkg~UTMY,sp.dat@data)

```

***For purposes of this exercise I will be using real stations but fake data randomly generated with an imposed spatial gradient for demonstration purposes.***

## Reading

To read shapefiles such as ESRI `.shp` files into R you can use the `readOGR` function in the `rgdal` library. Feel free to get familar with with function by typing `?readOGR` into the R console. Evertime I read a spatial dataset into R I also check the projection using `attributes(sp.data)$proj4string` to make sure all my spatial data is in the correct project. If necessary re-projection of the data is easy.

```
sp.dat=readOGR(dsn=".../data path/spatial data"),layer="SampleSites")
attributes(sp.data)$proj4string
```

If you have raw data file, like say from a GPS or a random excel file with lat/longs read in the file like you noramlly do using `read.csv()` or `openxlsx::read.xlsx()` and apply the necessary projection `proj.data`. Here is a great lesson on coordinate reference system with some R-code ([link](https://www.earthdatascience.org/courses/earth-analytics/spatial-data-r/intro-to-coordinate-reference-systems/){target="_blank"}) and some additional [information](https://rspatial.org/spatial/6-crs.html?highlight=coordinates#){target="_blank"} incase you are unfamilar with CRS and how it applies.

```
loc.dat.raw=read.csv(loc_data.csv)
```

```{r raw data example,echo=T,message=F,warning=F}
head(loc.dat.raw,2L)

proj.data=CRS("+proj=utm +zone=17 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0") 

loc.dat.raw=SpatialPointsDataFrame(coords=loc.dat.raw[,c("UTMX","UTMY")],
                                   data=loc.dat.raw,
                                   proj4string = proj.data)
```

It always good to take a look at the data spatially before moving forward to ensure the data is correct. You can use the generate `plot` function for a quick look at the data. 
```
plot(sp.dat,pch=21)

```
```{r quick plot,fig.height=4,fig.width=5,echo=FALSE,fig.align="center"}
par(family="serif",mar=c(1,1,1,1),oma=c(0.5,0.5,0.5,0.5));
plot(loc.dat.raw, pch=21)
box()
```

## Spatial Autocorrelation

Most if not all field data can be characterized as spatial data, especially in ecology. If something is sampled at a particular location there is a spatial component to the data. As such there are some spatial specific statistics that be applied to spatial data to explain how the data relates to the world. One such statistic is spatial autocorrelation. 

Spatial autocorrelation measures the degree to which a phenomenon of interest is correlated to itself in space. This statistical analysis evaluates whether the observed value of a variable at one location is independent of values of that variability at neighboring locations.

* Positive spatial autocorrelation indiates similar values appear close to each other (i.e. clustered in space).

* Negative spatial autocorrelation indicates that neighboring values are dissimilar (i.e. dispersed in space).

* No spatial autocorrelation indicates that the spatial pattern is completely random.

*Moran's I* is the most common spatial autocorrelation test however other tests are availalbe (i.e. Geary's C, Join Counts, etc.)


### Interpolations

***This section is modeled from [Chapter 14](https://mgimond.github.io/Spatial/spatial-interpolation.html){target="_blank"} of [Gimond (2018)](https://mgimond.github.io/Spatial/index.html){target="_blank"}.***

The most basic and simplest interpolation is proximity interpolation, where thiessen polygons are drawn based on the existing monitoring network to approimate all unsampled locations. This processes generates a tessellated surface whereby lines that split the midpoint betweem each sampled location are connected. One obvious issue with this approach is that values can change abruptly between tessilated boundries and may not accurately represent _in-situ_ conditions. 

Despite these downfalls, lets create a thessian polygon and see how the data looks. Using hte `dirichlet()` function, we can create a tessellated surfce very easily unfortunately it is not spatially explict (i.e. doesn't have a CRS). Also the surface extends beyond the study area, so it will need to be clipped to the extent of the study area (a seperate shapefile). 


```{r ,echo=T,message=F,warning=F}
# Generate Thessian polygon and assign CRS
th=as(dirichlet(as.ppp(sp.dat)),"SpatialPolygons")
proj4string(th)=proj4string(sp.dat)

# Join thessian polygon with actual data
th.z=over(th,sp.dat)

# Convert to a spatial polygon
th.spdf=SpatialPolygonsDataFrame(th,th.z)

# Clip to study area
th.clp=raster::intersect(study.area,th.spdf)
```

```{r thessian plot,fig.height=4,fig.width=6,echo=FALSE,fig.align="center",fig.cap="**Left:** All sampling points within the study area. **Middle:** Thessian polyon for all sampling locations. **Right:** Thessian polygons clipped to study area."}
par(family="serif",mar=c(1,1,1,1),oma=c(0.5,0.5,0.5,0.5));
layout(matrix(c(1:3),1,3,byrow=T))
plot(study.area,col="grey80")
plot(sp.dat,pch=19,add=T);box()

plot(study.area,border=F)
plot(th.spdf,add=T);box()

plot(study.area,border=F)
plot(th.clp,add=T);box()
```


As you can see sampling density can significantly affect how the thessian plots an thus representation of the data. Sampling density can also affect other spatial analyses (i.e. spatial autocorrelation) as well. 

```{r thessian data plot,message=F,warning=F,fig.height=4.5,fig.width=6,echo=FALSE,fig.align="center",fig.cap="Soil Total Phosphorus concentration (**NOT REAL DATA**)"}
tm_shape(th.clp) + 
  tm_polygons(col="TP_mgkg", palette="YlOrRd",border.col=NA,
              title="Total Phosphorus \n(mg/kg)") +
  tm_legend(legend.outside=TRUE)+
  tm_compass(north=0,position=c("left","top"))+
  tm_scale_bar(breaks=c(0,1),size=0.75,position=c("left","top"))+tm_layout(fontfamily = "serif",compass.type = "arrow")
```

***


## References
* Gimond M (2018) Intro to GIS and Spatial Analysis.

* Lovelace R, Nowosad J, Muenchow J (2019) Geocomputation with R, 1st edn. CRC Press, Boca Raton, FL
